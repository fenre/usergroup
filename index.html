<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Terminal</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            background-color: #000000; /* Black background */
            color: #ffffff; /* White text */
            font-family: 'Roboto Mono', monospace;
            font-size: 14px; /* Adjust as needed */
            line-height: 1.4;
        }

        /* Terminal Container */
        .terminal {
            height: 100%;
            padding: 15px;
            overflow-y: auto; /* Enable scrolling */
            cursor: text; /* Indicate text input area */
            display: flex;
            flex-direction: column;
        }

        /* Output Area */
        #output {
            flex-grow: 1; /* Take up available space */
            white-space: pre-wrap; /* Preserve whitespace and wrap lines */
            word-break: break-all; /* Break long words if necessary */
        }

        /* Input Line Container */
        .input-line {
            display: flex;
            align-items: center;
        }

        /* Prompt Style */
        .prompt {
            /* color: #00ff00; /* Green prompt */
            margin-right: 8px;
            flex-shrink: 0;
            white-space: nowrap;
        }
        .prompt-user { color: #00ff00; } /* Green user@host */
        .prompt-colon { color: #ffffff; } /* White colon */
        .prompt-path { color: #7aa2f7; } /* Blue path */
        .prompt-dollar { color: #ffffff; } /* White $ */


        /* Container for the visible input text and cursor */
        .input-area-container {
             position: relative; /* Needed for hidden input positioning */
             flex-grow: 1;
             display: flex; /* Use flex to keep parts together */
             align-items: center;
             min-width: 1px; /* Ensure it can shrink */
             white-space: pre; /* Preserve spaces within the input spans */
             flex-wrap: wrap; /* Allow wrapping for long inputs */
        }

        /* Spans for text before/after cursor */
        #beforeCursor, #afterCursor {
            display: inline; /* Keep text flowing */
            outline: none;
        }

        /* Actual Hidden Input Field */
        #commandInput {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0; /* Make it invisible */
            cursor: text; /* Keep text cursor */
            border: none;
            background: transparent;
            color: transparent; /* Hide typed text in the actual input */
            caret-color: transparent; /* Hide the input's own caret */
            padding: 0;
            margin: 0;
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
            white-space: pre; /* Match wrapping behavior */
        }

        /* Blinking Cursor */
        .cursor {
            display: inline-block;
            background-color: #ffffff; /* White cursor */
            width: 8px; /* Width of the cursor block */
            height: 1.4em; /* Match line height */
            vertical-align: middle; /* Align with text */
            animation: blink 1s step-end infinite;
            order: 1; /* Ensure cursor is positioned correctly in flex layout */
            flex-shrink: 0;
        }
        /* Hide cursor when input is not focused */
        #commandInput:not(:focus) + .cursor {
             animation: none; /* Stop blinking */
             opacity: 0.5; /* Make it faint */
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* Output formatting */
        .output-command { color: #ffffff; }
        .output-ls-dir { color: #7aa2f7; font-weight: bold; } /* Blue bold for directories */
        .output-ls-file { color: #ffffff; } /* White for files */
        .output-ls span { display: inline-block; margin-right: 15px; } /* Common spacing */
        .output-error { color: #f7768e; } /* Red for errors */
        .output-info { color: #e0af68; } /* Yellow/Orange for info */
        .output-less-content {
            color: #bb9af7; /* Purple for file content */
            border-top: 1px dashed #414868; /* Separator line */
            border-bottom: 1px dashed #414868; /* Separator line */
            margin-top: 5px;
            margin-bottom: 5px;
            padding-top: 5px;
            padding-bottom: 5px;
            white-space: pre-wrap; /* Ensure content formatting is preserved */
        }

    </style>
</head>
<body>

    <div id="terminal" class="terminal" onclick="focusInput()">
        <div id="output">
            <div class="output-info">Welcome to the Oslo Splunk User Group Docs! Type 'help' for commands.</div>
        </div>
        <div class="input-line">
            <span id="prompt" class="prompt"></span>
            <div class="input-area-container">
                <span id="beforeCursor"></span>
                <span class="cursor"></span>
                <span id="afterCursor"></span>
                <input type="text" id="commandInput" spellcheck="false" autocomplete="off" autocapitalize="none" autofocus>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const terminal = document.getElementById('terminal');
        const outputDiv = document.getElementById('output');
        const beforeCursorSpan = document.getElementById('beforeCursor');
        const afterCursorSpan = document.getElementById('afterCursor');
        const commandInput = document.getElementById('commandInput');
        const cursorElement = document.querySelector('.cursor');
        const promptElement = document.getElementById('prompt');

        // --- File System Simulation ---
        // Represents the directory structure and file contents
        const fileSystem = {
            // Root directory '/'
            'about.html': `<h1>About Us</h1>
<p>This is the documentation page for the Oslo Splunk User Group.</p>
<p>Navigate using 'cd', list files with 'ls', view content with 'less'.</p>`,
            'contact.txt': `Contact Information:
--------------------
Meetup Group: [Link to Meetup]
Email: oslo-splunk-ug@example.com (replace)
Organizers: [List Names]`,
            'README2.md': `# Oslo Splunk User Group Docs

Welcome! This page provides information and resources for the OSUG.

Use the terminal interface to navigate:
- \`ls\`: List files/directories in the current location.
- \`cd <directory>\`: Change into a directory.
- \`cd ..\`: Go up one directory.
- \`less <filename>\`: View file content.
- \`help\`: Show available commands.`,
            'events': { // Directory 'events'
                'type': 'directory', // Mark as directory
                'past_meetups.md': `# Past Meetups
- Q1 2025: Observability with Splunk
- Q4 2024: Security Monitoring Techniques`,
                'upcoming.txt': `Next Meetup: Q2 2025 - Splunk for Security
Date: June 15, 2025
Location: Online
Details: [Link to details/RSVP]`
            },
            'resources': { // Directory 'resources'
                'type': 'directory',
                'splunk_links.txt': `Useful Splunk Links:
- Splunk Docs: https://docs.splunk.com/
- Splunk Community: https://community.splunk.com/
- Splunkbase: https://splunkbase.splunk.com/`,
                'presentations': { // Sub-directory 'presentations'
                    'type': 'directory',
                    'q1_2025_slides.pdf': '(Simulated PDF content - Q1 2025)' // File inside sub-directory
                }
            }
        };

        // --- State ---
        let currentPath = []; // Array representing the current directory path, starts at root []

        // --- Utility Functions ---

        /**
         * Gets the current directory object from the file system based on currentPath.
         * @returns {object} The current directory object.
         */
        function getCurrentDirectory() {
            let currentLevel = fileSystem;
            for (const dir of currentPath) {
                // Navigate down the file system tree
                if (currentLevel[dir] && typeof currentLevel[dir] === 'object' && currentLevel[dir].type === 'directory') {
                    currentLevel = currentLevel[dir];
                } else {
                    // Safety check for invalid paths - should ideally not be reached
                    console.error("Invalid path encountered:", currentPath);
                    return fileSystem; // Fallback to root
                }
            }
            return currentLevel;
        }

        /**
         * Gets the object (file or directory) at a specific name relative to the current directory.
         * @param {string} name - The name of the file or directory.
         * @returns {object|string|undefined} The file/directory object/content or undefined if not found.
         */
        function getObjectAtPath(name) {
            const currentDir = getCurrentDirectory();
            return currentDir[name];
        }

        /**
         * Updates the command prompt display based on the current path.
         */
        function updatePrompt() {
            // Construct path string (~ for root, ~/dir1/dir2 otherwise)
            const pathString = currentPath.length === 0 ? '~' : `~/${currentPath.join('/')}`;
            // Use innerHTML to allow styled spans within the prompt
            promptElement.innerHTML = `<span class="prompt-user">guest@splunk-UG</span><span class="prompt-colon">:</span><span class="prompt-path">${pathString}</span><span class="prompt-dollar">$</span>`;
        }

        // --- Core Terminal Functions ---

        /**
         * Focuses the hidden command input field.
         */
        function focusInput() {
            commandInput.focus();
            updateInputArea(); // Ensure cursor position/visibility is updated
        }

        /**
         * Updates the visible input area (before/after cursor spans) based on the hidden input's value and caret position.
         */
        function updateInputArea() {
            const value = commandInput.value;
            const selectionStart = commandInput.selectionStart; // Caret position
            // Update text before the cursor
            beforeCursorSpan.textContent = value.substring(0, selectionStart);
            // Update text after the cursor
            afterCursorSpan.textContent = value.substring(selectionStart);
            // Scrolling is handled after command execution or potentially on input if needed
        }

        /**
         * Handles keydown events, primarily looking for the Enter key to process commands.
         * @param {KeyboardEvent} event - The keydown event object.
         */
        function handleKeyDown(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default newline insertion/form submission
                processCommand();
            }
            // Future enhancements: Handle ArrowUp/Down for history, Tab for autocomplete
        }

        /**
         * Processes the command entered by the user.
         */
         function processCommand() {
            const fullCommand = commandInput.value.trim(); // Get and trim the command

            // Construct the prompt string as it was when the command was entered for echoing
            const pathString = currentPath.length === 0 ? '~' : `~/${currentPath.join('/')}`;
            const promptForEcho = `guest@splunk-UG:${pathString}$`;
            // Echo the full command line to the output
            appendOutput(`${promptForEcho} ${fullCommand}`, 'output-command');

            // Proceed only if a command was actually entered
            if (fullCommand) {
                const args = fullCommand.split(' '); // Split command into parts
                const command = args[0].toLowerCase(); // The command is the first part

                // Check if the command exists in our command map
                if (commands[command]) {
                    try {
                        // Execute the corresponding command function, passing arguments
                        commands[command](args.slice(1));
                    } catch (error) {
                        // Basic error handling for command execution failures
                        console.error("Command execution error:", error);
                        appendOutput(`Error executing ${command}: ${error.message}`, 'output-error');
                    }
                } else {
                    // Command not found
                    appendOutput(`bash: command not found: ${command}`, 'output-error');
                }
            }

            // Reset for the next command
            commandInput.value = ''; // Clear the hidden input
            updateInputArea(); // Update the visible input display
            updatePrompt(); // Update the prompt (important after 'cd')
            scrollToBottom(); // Ensure the new prompt line is visible
        }

        /**
         * Appends a new line of text to the terminal output.
         * @param {string} text - The text to append.
         * @param {string} [className=''] - Optional CSS class(es) to apply to the new line.
         */
        function appendOutput(text, className = '') {
            const newLine = document.createElement('div');
            if (className) {
                newLine.className = className;
            }
            // Use textContent to prevent accidental HTML injection from file contents or command output
            newLine.textContent = text;
            outputDiv.appendChild(newLine);
        }

        /**
         * Scrolls the terminal view to the bottom, but only if the user is already near the bottom.
         */
        function scrollToBottom() {
            // Check if the user is scrolled near the bottom (within ~5px tolerance)
            const isScrolledToBottom = terminal.scrollHeight - terminal.clientHeight <= terminal.scrollTop + 5;
            if(isScrolledToBottom) {
                 terminal.scrollTop = terminal.scrollHeight; // Auto-scroll
            }
        }

        // --- Command Implementations ---

        /**
         * Implements the 'ls' command. Lists files and directories in the current directory.
         */
        function listFiles() {
            const currentDir = getCurrentDirectory();
            const lsOutputContainer = document.createElement('div');
            lsOutputContainer.className = 'output-ls'; // Class for styling the ls output block

            // Get items, excluding the internal 'type' marker for directories
            const items = Object.keys(currentDir).filter(key => key !== 'type');

            // If directory is empty, do nothing (or optionally show a message)
            if (items.length === 0) {
                return;
            }

            // Sort items alphabetically for consistent listing
            items.sort();

            // Create spans for each item with appropriate styling
            items.forEach(item => {
                const itemSpan = document.createElement('span');
                const obj = currentDir[item];
                // Check if the item is a directory
                if (typeof obj === 'object' && obj.type === 'directory') {
                    itemSpan.className = 'output-ls-dir'; // Directory style
                    itemSpan.textContent = item + '/'; // Append slash for directories
                } else {
                    itemSpan.className = 'output-ls-file'; // File style
                    itemSpan.textContent = item;
                }
                lsOutputContainer.appendChild(itemSpan);
            });
            outputDiv.appendChild(lsOutputContainer); // Add the formatted list to the output
        }

        /**
         * Implements the 'cd' command. Changes the current working directory.
         * @param {string[]} args - Arguments passed to the cd command (expecting zero or one).
         */
        function changeDirectory(args) {
            const target = args[0] || ''; // Target directory name, '..', or empty for home/root

            // Handle 'cd' or 'cd ~' to go to root
            if (target === '' || target === '~') {
                currentPath = []; // Reset path to root
                return; // No further action needed
            }

            // Handle 'cd ..' to go up one directory
            if (target === '..') {
                if (currentPath.length > 0) {
                    currentPath.pop(); // Remove the last element from the path array
                } // If already at root, do nothing
                return; // No further action needed
            }

            // Handle 'cd .' to stay in the current directory (no-op)
            if (target === '.') {
                return;
            }

            // Handle changing into a specific subdirectory
            const currentDir = getCurrentDirectory();
            const targetDir = currentDir[target]; // Get the target object

            if (targetDir && typeof targetDir === 'object' && targetDir.type === 'directory') {
                // If it exists and is a directory, add it to the path
                currentPath.push(target);
            } else if (targetDir) {
                // If it exists but isn't a directory
                appendOutput(`bash: cd: ${target}: Not a directory`, 'output-error');
            } else {
                // If it doesn't exist
                appendOutput(`bash: cd: ${target}: No such file or directory`, 'output-error');
            }
            // Prompt update happens automatically after command execution
        }


        /**
         * Implements the 'less' command. Displays the content of a specified file.
         * @param {string[]} args - Arguments passed to the less command (expecting one filename).
         */
        function showFileContent(args) {
            const filename = args[0]; // Get the filename argument

            // Check if filename was provided
            if (!filename) {
                appendOutput('less: missing filename', 'output-error');
                return;
            }
            // Basic validation: prevent path traversal attempts in filename
            if (filename.includes('/') || filename === '..' || filename === '.') {
                 appendOutput(`less: Invalid filename '${filename}'`, 'output-error');
                 return;
            }

            // Get the object (file or directory) from the current directory
            const targetObject = getObjectAtPath(filename);

            if (targetObject) {
                // Check if it's a directory
                if (typeof targetObject === 'object' && targetObject.type === 'directory') {
                    appendOutput(`less: ${filename}: Is a directory`, 'output-error');
                }
                // Check if it's a string (our representation of file content)
                else if (typeof targetObject === 'string') {
                    // Display the file content with specific styling
                    appendOutput(targetObject, 'output-less-content');
                } else {
                    // Should not happen with current structure, but catch unexpected types
                     appendOutput(`less: cannot view contents of '${filename}'`, 'output-error');
                }
            } else {
                // File not found in the current directory
                appendOutput(`less: ${filename}: No such file or directory`, 'output-error');
            }
        }

        /**
         * Implements the 'help' command. Displays a list of available commands.
         */
        function showHelp() {
            appendOutput('Available commands:', 'output-info');
            appendOutput(`  ls              List files and directories`);
            appendOutput(`  cd <dir>        Change directory (use '..' to go up, empty or '~' to go home)`);
            appendOutput(`  less <filename> View file content`);
            appendOutput(`  help            Show this help message`);
            appendOutput(`  clear           Clear the terminal screen`);
            appendOutput(`  date            Show the current date and time`);
            appendOutput("Use arrow keys to move cursor (basic).", 'output-info');
        }

        /**
         * Implements the 'clear' command. Clears the terminal output area.
         */
        function clearScreen() {
            outputDiv.innerHTML = ''; // Remove all child elements from output
        }

        /**
         * Implements the 'date' command. Displays the current date and time.
         */
        function showDate() {
            appendOutput(new Date().toString());
        }

        // --- Command Map ---
        // Maps command strings to their corresponding implementation functions
        const commands = {
            'ls': listFiles,
            'cd': changeDirectory,
            'less': showFileContent,
            'help': showHelp,
            'clear': clearScreen,
            'date': showDate,
        };


        // --- Initial Setup ---
        updatePrompt(); // Display the initial prompt
        updateInputArea(); // Set initial cursor position display
        focusInput(); // Focus the input field on load

        // --- Event Listeners --- (Setup after functions are defined)
        terminal.addEventListener('click', focusInput); // Focus input on terminal click
        commandInput.addEventListener('keydown', handleKeyDown); // Handle Enter key
        commandInput.addEventListener('input', updateInputArea); // Update display on typing
        commandInput.addEventListener('keyup', updateInputArea); // Update display on arrow keys, etc.
        commandInput.addEventListener('mouseup', updateInputArea); // Update display on mouse selection change
        commandInput.addEventListener('focus', updateInputArea); // Update cursor on focus
        commandInput.addEventListener('blur', updateInputArea); // Update cursor on blur

    </script>

</body>
</html>
