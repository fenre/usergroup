<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Terminal - fenre/usergroup</title> <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; background-color: #000000; color: #ffffff; font-family: 'Roboto Mono', monospace; font-size: 14px; line-height: 1.4; }
        .terminal { height: 100%; padding: 15px; overflow-y: auto; cursor: text; display: flex; flex-direction: column; }
        #output { flex-grow: 1; white-space: pre-wrap; word-break: break-all; }
        .input-line { display: flex; align-items: center; }
        .prompt { margin-right: 8px; flex-shrink: 0; white-space: nowrap; }
        .prompt-user { color: #00ff00; }
        .prompt-colon { color: #ffffff; }
        .prompt-path { color: #7aa2f7; }
        .prompt-dollar { color: #ffffff; }
        .input-area-container { position: relative; flex-grow: 1; display: flex; align-items: center; min-width: 1px; white-space: pre; flex-wrap: wrap; }
        #beforeCursor, #afterCursor { display: inline; outline: none; }
        #commandInput { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: text; border: none; background: transparent; color: transparent; caret-color: transparent; padding: 0; margin: 0; font: inherit; white-space: pre; }
        .cursor { display: inline-block; background-color: #ffffff; width: 8px; height: 1.4em; vertical-align: middle; animation: blink 1s step-end infinite; order: 1; flex-shrink: 0; }
        #commandInput:not(:focus) + .cursor { animation: none; opacity: 0.5; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        /* Output Formatting */
        .output-command { color: #ffffff; }
        .output-ls-dir { color: #7aa2f7; font-weight: bold; }
        .output-ls-file { color: #ffffff; }
        .output-ls span { display: inline-block; margin-right: 15px; }
        .output-error { color: #f7768e; }
        .output-info { color: #e0af68; }
        .output-loading { color: #e0af68; font-style: italic; } /* Style for loading messages */
        .output-less-content { color: #bb9af7; border-top: 1px dashed #414868; border-bottom: 1px dashed #414868; margin-top: 5px; margin-bottom: 5px; padding-top: 5px; padding-bottom: 5px; white-space: pre-wrap; }
    </style>
</head>
<body>

    <div id="terminal" class="terminal" onclick="focusInput()">
        <div id="output">
            <div class="output-info">Connecting to GitHub repo: fenre/usergroup... Type 'help' for commands.</div>
        </div>
        <div class="input-line">
            <span id="prompt" class="prompt"></span>
            <div class="input-area-container">
                <span id="beforeCursor"></span>
                <span class="cursor"></span>
                <span id="afterCursor"></span>
                <input type="text" id="commandInput" spellcheck="false" autocomplete="off" autocapitalize="none" autofocus disabled> </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const terminal = document.getElementById('terminal');
        const outputDiv = document.getElementById('output');
        const beforeCursorSpan = document.getElementById('beforeCursor');
        const afterCursorSpan = document.getElementById('afterCursor');
        const commandInput = document.getElementById('commandInput');
        const cursorElement = document.querySelector('.cursor');
        const promptElement = document.getElementById('prompt');

        // --- GitHub API Configuration ---
        const GITHUB_OWNER = 'fenre';
        const GITHUB_REPO = 'usergroup';
        const GITHUB_API_BASE = 'https://api.github.com';
        // NOTE: No token included for public access. Add Authorization header if needed for private repos (requires secure handling).
        const GITHUB_HEADERS = {
            'Accept': 'application/vnd.github.v3+json',
            // 'Authorization': 'token YOUR_GITHUB_TOKEN' // **NEVER hardcode tokens here for public sites!**
        };

        // --- State ---
        let currentPath = []; // Array representing the current directory path, starts at root []
        let isReady = false; // Flag to indicate if the terminal is ready for input

        // --- Utility Functions ---

        /**
         * Constructs the API URL for repository contents.
         * @returns {string} The GitHub API URL for the current path.
         */
        function getApiUrlForCurrentPath() {
            const pathString = currentPath.join('/');
            return `${GITHUB_API_BASE}/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${pathString}`;
        }

        /**
         * Fetches data from the GitHub API.
         * @param {string} url - The API URL to fetch.
         * @returns {Promise<any>} A promise that resolves with the JSON response or rejects on error.
         */
        async function fetchFromGitHub(url) {
            try {
                const response = await fetch(url, { headers: GITHUB_HEADERS });
                if (!response.ok) {
                    // Handle specific errors like 404 or rate limiting
                    if (response.status === 404) {
                        throw new Error(`Not Found: ${url.replace(GITHUB_API_BASE,'')}`);
                    } else if (response.status === 403) {
                         const rateLimitInfo = `Rate limit: ${response.headers.get('X-RateLimit-Limit')}, Remaining: ${response.headers.get('X-RateLimit-Remaining')}`;
                         console.warn('Rate limit likely exceeded.', await response.json());
                         throw new Error(`API request forbidden (check rate limits or token permissions). ${rateLimitInfo}`);
                    }
                    throw new Error(`GitHub API Error: ${response.status} ${response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error('Fetch error:', error);
                // Re-throw the error so command functions can handle it
                throw error;
            }
        }


        /**
         * Updates the command prompt display based on the current path.
         */
        function updatePrompt() {
            const pathString = currentPath.length === 0 ? '~' : `~/${currentPath.join('/')}`;
            promptElement.innerHTML = `<span class="prompt-user">guest@${GITHUB_REPO}</span><span class="prompt-colon">:</span><span class="prompt-path">${pathString}</span><span class="prompt-dollar">$</span>`;
        }

        // --- Core Terminal Functions ---

        function focusInput() {
            if (isReady) { // Only allow focus if ready
                 commandInput.focus();
            }
            updateInputArea();
        }

        function updateInputArea() {
            const value = commandInput.value;
            const selectionStart = commandInput.selectionStart;
            beforeCursorSpan.textContent = value.substring(0, selectionStart);
            afterCursorSpan.textContent = value.substring(selectionStart);
        }

        function handleKeyDown(event) {
             if (!isReady) return; // Ignore input if not ready
            if (event.key === 'Enter') {
                event.preventDefault();
                processCommand(); // Now async
            }
        }

        /**
         * Processes the command entered by the user asynchronously.
         */
        async function processCommand() {
            if (!isReady) return; // Should not happen if input is disabled, but safety check

            const fullCommand = commandInput.value.trim();
            const pathString = currentPath.length === 0 ? '~' : `~/${currentPath.join('/')}`;
            const promptForEcho = `guest@${GITHUB_REPO}:${pathString}$`;
            appendOutput(`${promptForEcho} ${fullCommand}`, 'output-command');

            // Disable input while processing
            isReady = false;
            commandInput.disabled = true;
            setLoadingState(true); // Show loading cursor/indicator (optional)

            if (fullCommand) {
                const args = fullCommand.split(' ');
                const command = args[0].toLowerCase();

                if (commands[command]) {
                    try {
                        // Await the async command function
                        await commands[command](args.slice(1));
                    } catch (error) {
                        // Handle errors thrown by command functions (e.g., API errors)
                        appendOutput(`${error.message || 'Command failed'}`, 'output-error');
                    }
                } else {
                    appendOutput(`bash: command not found: ${command}`, 'output-error');
                }
            }

            // Re-enable input
            commandInput.value = '';
            updateInputArea();
            updatePrompt();
            isReady = true;
            commandInput.disabled = false;
            setLoadingState(false); // Hide loading state
            scrollToBottom();
            // Refocus after command execution might be needed depending on browser behavior
            // requestAnimationFrame(focusInput); // Use rAF to focus after potential DOM updates
        }

        /**
         * Sets a visual loading state (e.g., changing cursor style).
         * @param {boolean} isLoading - Whether the terminal is loading data.
         */
        function setLoadingState(isLoading) {
             terminal.style.cursor = isLoading ? 'wait' : 'text';
             // You could also add/remove a class to the body or terminal element
             // to show a more prominent loading indicator if desired.
        }


        function appendOutput(text, className = '') {
            const newLine = document.createElement('div');
            if (className) {
                newLine.className = className;
            }
            newLine.textContent = text;
            outputDiv.appendChild(newLine);
        }

        function scrollToBottom() {
            const isScrolledToBottom = terminal.scrollHeight - terminal.clientHeight <= terminal.scrollTop + 10; // Increased tolerance
            if(isScrolledToBottom) {
                 terminal.scrollTop = terminal.scrollHeight;
            }
        }

        // --- Command Implementations (Now Async) ---

        /**
         * Implements the 'ls' command using GitHub API.
         */
        async function listFiles() {
            const apiUrl = getApiUrlForCurrentPath();
            appendOutput(`Fetching ${apiUrl.replace(GITHUB_API_BASE,'')}...`, 'output-loading'); // Loading message
            try {
                const data = await fetchFromGitHub(apiUrl);

                if (!Array.isArray(data)) {
                     appendOutput('Error: Expected directory listing but received unexpected data.', 'output-error');
                     console.error("Unexpected data format for ls:", data);
                     return;
                }

                if (data.length === 0) {
                    return; // Empty directory, no output needed
                }

                const lsOutputContainer = document.createElement('div');
                lsOutputContainer.className = 'output-ls';

                // Sort items: directories first, then files, alphabetically
                 data.sort((a, b) => {
                    if (a.type === b.type) {
                        return a.name.localeCompare(b.name); // Sort alphabetically if same type
                    }
                    return a.type === 'dir' ? -1 : 1; // Directories first
                 });


                data.forEach(item => {
                    const itemSpan = document.createElement('span');
                    if (item.type === 'dir') {
                        itemSpan.className = 'output-ls-dir';
                        itemSpan.textContent = item.name + '/';
                    } else if (item.type === 'file') {
                        itemSpan.className = 'output-ls-file';
                        itemSpan.textContent = item.name;
                    } else {
                        // Handle other types like symlinks if necessary
                        itemSpan.textContent = item.name + ` (${item.type})`;
                    }
                    lsOutputContainer.appendChild(itemSpan);
                });
                outputDiv.appendChild(lsOutputContainer);

            } catch (error) {
                // Error already logged by fetchFromGitHub, just display message
                appendOutput(`ls: ${error.message}`, 'output-error');
            } finally {
                 // Remove loading message? Optional. Could find and remove the specific loading div.
            }
        }

        /**
         * Implements the 'cd' command using GitHub API for validation.
         */
        async function changeDirectory(args) {
            const target = args[0] || '';

            if (target === '' || target === '~') {
                currentPath = [];
                return; // Success, no API call needed
            }

            if (target === '..') {
                if (currentPath.length > 0) {
                    currentPath.pop();
                }
                return; // Success, no API call needed
            }

            if (target === '.') {
                return; // Success, no-op
            }

             if (target.includes('/')) {
                 appendOutput(`cd: Invalid directory name '${target}'`, 'output-error');
                 return;
             }

            // Check if target exists and is a directory via API
            const targetPath = [...currentPath, target].join('/');
            const apiUrl = `${GITHUB_API_BASE}/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${targetPath}`;
            appendOutput(`Checking path ${targetPath}...`, 'output-loading');

            try {
                // We fetch the target path. If it's a directory, the API returns an array (its contents).
                // If it's a file, it returns an object. If it doesn't exist, it throws 404.
                const data = await fetchFromGitHub(apiUrl);

                if (Array.isArray(data)) {
                    // It's a directory, success! Update the path.
                    currentPath.push(target);
                } else if (typeof data === 'object' && data.type === 'file') {
                    // It's a file, not a directory
                    appendOutput(`bash: cd: ${target}: Not a directory`, 'output-error');
                } else {
                     // Unexpected response type
                     appendOutput(`bash: cd: ${target}: Not a directory or unable to access`, 'output-error');
                     console.warn("Unexpected response for cd target:", data);
                }
            } catch (error) {
                 // Handle errors (like 404 Not Found)
                 if (error.message.includes('Not Found')) {
                     appendOutput(`bash: cd: ${target}: No such file or directory`, 'output-error');
                 } else {
                      appendOutput(`cd: ${error.message}`, 'output-error'); // Display other API errors
                 }
            }
        }


        /**
         * Implements the 'less' command using GitHub API.
         */
        async function showFileContent(args) {
            const filename = args[0];

            if (!filename) {
                appendOutput('less: missing filename', 'output-error');
                return;
            }
            if (filename.includes('/') || filename === '..' || filename === '.') {
                 appendOutput(`less: Invalid filename '${filename}'`, 'output-error');
                 return;
            }

            const targetPath = [...currentPath, filename].join('/');
            const apiUrl = `${GITHUB_API_BASE}/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${targetPath}`;
            appendOutput(`Fetching ${filename}...`, 'output-loading');

            try {
                const data = await fetchFromGitHub(apiUrl);

                if (typeof data === 'object' && data.type === 'file') {
                    if (data.encoding !== 'base64') {
                         appendOutput(`less: Unsupported file encoding: ${data.encoding || 'unknown'}`, 'output-error');
                         return;
                    }
                    // Decode base64 content
                    const decodedContent = atob(data.content);
                    appendOutput(decodedContent, 'output-less-content');
                } else if (Array.isArray(data) || (typeof data === 'object' && data.type === 'dir')) {
                     appendOutput(`less: ${filename}: Is a directory`, 'output-error');
                } else {
                     appendOutput(`less: Error reading ${filename}: Unexpected API response`, 'output-error');
                     console.warn("Unexpected response for less target:", data);
                }

            } catch (error) {
                 if (error.message.includes('Not Found')) {
                     appendOutput(`less: ${filename}: No such file or directory`, 'output-error');
                 } else {
                      appendOutput(`less: ${error.message}`, 'output-error');
                 }
            }
        }

        /**
         * Implements the 'help' command.
         */
        function showHelp() { // This command doesn't need to be async
            appendOutput('Available commands:', 'output-info');
            appendOutput(`  ls              List files and directories in current path`);
            appendOutput(`  cd <dir>        Change directory (use '..' to go up, empty or '~' to go home)`);
            appendOutput(`  less <filename> View file content`);
            appendOutput(`  help            Show this help message`);
            appendOutput(`  clear           Clear the terminal screen`);
            appendOutput(`  date            Show the current date and time`);
            appendOutput(`Connected to GitHub repo: ${GITHUB_OWNER}/${GITHUB_REPO}`, 'output-info');
        }

        /**
         * Implements the 'clear' command.
         */
        function clearScreen() { // No need to be async
            outputDiv.innerHTML = '';
        }

        /**
         * Implements the 'date' command.
         */
        function showDate() { // No need to be async
            appendOutput(new Date().toString());
        }

        // --- Command Map ---
        const commands = {
            'ls': listFiles, // async
            'cd': changeDirectory, // async
            'less': showFileContent, // async
            'help': showHelp, // sync
            'clear': clearScreen, // sync
            'date': showDate, // sync
        };


        // --- Initial Setup ---
        async function initializeTerminal() {
            updatePrompt();
            updateInputArea();
            // Optional: Perform an initial 'ls' or check root access
            try {
                // Test connection by fetching root
                await fetchFromGitHub(getApiUrlForCurrentPath());
                appendOutput(`Successfully connected to ${GITHUB_OWNER}/${GITHUB_REPO}.`, 'output-info');
                isReady = true;
                commandInput.disabled = false;
                focusInput();
            } catch (error) {
                 appendOutput(`Error connecting to repository: ${error.message}`, 'output-error');
                 appendOutput('Please check repository details and network connection.', 'output-error');
                 // Keep input disabled if connection fails
            }
        }

        // Add event listeners
        terminal.addEventListener('click', focusInput);
        commandInput.addEventListener('keydown', handleKeyDown);
        commandInput.addEventListener('input', updateInputArea);
        commandInput.addEventListener('keyup', updateInputArea);
        commandInput.addEventListener('mouseup', updateInputArea);
        commandInput.addEventListener('focus', updateInputArea);
        commandInput.addEventListener('blur', updateInputArea);

        // Start the initialization
        initializeTerminal();

    </script>

</body>
</html>
